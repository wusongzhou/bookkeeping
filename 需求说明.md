# 个人物品成本管理与云端同步应用 - 需求说明

## 1. 项目背景与目标

- **目标用户**：个人用户（自己使用）。
- **使用场景**：记录日常购买的物品（电子产品、家居用品、工具等），了解物品使用成本，并支持多设备（Web、Android）之间的数据共享。
- **主要目标**：
  - 管理物品的基本信息与状态。
  - 自动计算物品的使用天数与日均价格。
  - 支持物品“退役/归档”，归档后锁定日均价格。
  - 支持本地 SQLite 存储，保证离线可用。
  - 支持与云端数据库的数据同步，实现跨设备共享和云端备份。
  - 支持 Web 端和 Android App 双端使用。

## 2. 功能需求

### 2.1 物品信息管理与成本计算

#### 2.1.1 物品信息字段

每个物品至少包含以下字段：

- `名称`（必填，字符串）
- `购买时间`（必填，日期，精确到日即可）
- `购买价格`（必填，数字，建议内部以“分”为单位存储整数）
- `备注`（可选，字符串）
- `创建时间`（系统生成，ISO 时间字符串）
- `更新时间`（系统生成，ISO 时间字符串）

> 可根据实际需求扩展字段，如分类、标签、购买渠道等。

#### 2.1.2 使用天数计算

- 定义：  
  使用天数 = 终止日期 - 购买日期
- 终止日期规则：
  - 对于未归档物品：终止日期 = 当前日期。
  - 对于已归档物品：终止日期 = 归档日期（锁定时刻）。
- 计算规则：
  - 以自然日为粒度（忽略具体时间点）。
  - 若终止日期与购买日期为同一天，使用天数至少按 1 天计算，避免出现除以 0 的情况。
- 展示形式：
  - 示例：`已使用 123 天`，或 `使用 365 天后归档`。

#### 2.1.3 日均价格计算

- 定义：  
  日均价格 = 购买价格 ÷ 使用天数
- 计算规则：
  - 内部以“分”为单位进行整数运算，前端展示时转换为“元”，保留 2 位小数。
  - 使用天数为 0 时，按 1 天计算。
- 展示形式：
  - 示例：`日均成本：￥1.23 / 天`。
- 更新机制：
  - **未归档物品**：日均价格随当前日期变化（使用天数增加，日均价格动态更新）。
  - **已归档物品**：日均价格锁定，不再随时间变化（归档逻辑见 2.2）。

### 2.2 物品归档 / 退役机制

#### 2.2.1 归档概念

- 归档（或退役）表示物品已经结束使用：丢弃、捐赠、转卖等。
- 归档的目的：
  - 锁定物品的最终使用成本（日均价格）。
  - 区分“正在使用中”的物品与“历史物品”。

#### 2.2.2 归档操作

- 在物品列表或详情页提供“归档/退役”操作入口。
- 用户点击归档时，系统执行：
  1. 获取当前日期作为归档日期。
  2. 根据“购买日期”和“归档日期”计算最终使用天数。
  3. 根据最终使用天数，计算归档日均价格。
  4. 将计算出的日均价格写入“归档日均价格”字段。
  5. 将物品状态设为“已归档”，记录归档时间。

#### 2.2.3 归档后的行为

- 日均价格锁定：
  - 展示时直接使用“归档日均价格”，不再根据当前日期重算。
- 使用天数展示：
  - 使用归档时的最终使用天数，例如：`使用 365 天后归档`。
- 列表与筛选：
  - 支持筛选：只看进行中 / 只看已归档 / 全部。
  - 已归档物品需有明显的状态标识。

#### 2.2.4 取消归档（可选）

- 可选需求：支持将已归档物品重新标记为“进行中”。
- 取消归档行为：
  - 状态恢复为“未归档”。
  - 日均价格恢复为随当前日期变化的动态计算。
  - 是否清空“归档日均价格”和“归档时间”可以在实现时确定。

## 3. 云端同步与跨设备数据共享

### 3.1 同步目标与范围

- **目标**：
  - 将本地 SQLite 中的物品数据与云端数据库保持双向同步。
  - 实现 Web 端和 Android 端的数据共享与一致性。
  - 确保归档状态、使用天数相关字段、日均价格相关字段等关键信息在各端保持一致。
- **范围**：
  - 主要同步 `items` 表。
  - 后续如引入分类/标签等表，也可纳入同步。

### 3.2 同步场景与方向

- **同步方向**：
  - 本地 → 云端：用户在任意设备上新增/编辑/删除物品，变更需要同步到云端。
  - 云端 → 本地：其他设备或 Web 端产生的变更，需要同步回当前设备。
- **离线场景**：
  - 在无网络环境下，用户仍可对本地数据进行完整操作。
  - 所有操作在本地记录，待网络恢复后再与云端对账。

### 3.3 一致性与冲突策略

- **一致性要求**：
  - 不要求强实时同步，允许短暂的延迟。
  - 要求最终一致性：经过一次或多次同步后，各端数据趋于一致。
- **冲突处理（初版策略）**：
  - 采用“**最后修改时间优先**”策略：
    - 对于同一条记录，如果云端与本地的 `updated_at` 不同，以时间较晚的一方为准。
    - 本地与云端同步时根据 `updated_at` 做覆盖。
  - 后续可以扩展更复杂规则（如变更日志、手动选择版本等）。

### 3.4 同步触发方式

- **手动同步（必选）**：
  - 应用中提供“同步”按钮。
  - 用户点击后执行一次完整同步流程：
    1. 本地变更推送到云端。
    2. 从云端拉取最新变更更新本地。
- **自动同步（可选）**：
  - 应用启动时自动尝试同步。
  - 后台定期（如每 10 分钟）检测网络并自动同步。

## 4. 技术栈与整体架构

### 4.1 客户端技术栈

- **前端框架**：Next.js
  - 提供 Web 端 UI。
  - 页面以客户端渲染（CSR）为主，尽量兼容静态导出，便于移动端封装。
- **移动端封装**：Capacitor
  - 将前端构建产物封装为 Android 应用。
  - 通过 Capacitor 插件访问本地 SQLite、文件系统等原生能力。
- **本地数据库**：SQLite
  - Android 端使用原生 SQLite（通过 Capacitor 插件，如 `@capacitor-community/sqlite`）。
  - Web 端可以使用 IndexedDB 或 WebAssembly SQLite，通过统一的数据访问层封装出与 SQLite 类似的接口。

### 4.2 云端技术栈

- **后端运行环境**：
  - 部署在闲置云服务器，可使用 Node.js 环境。
- **后端框架（建议）**：
  - 方案一：直接使用 Next.js 的 API Routes 作为简单后端。
  - 方案二：单独使用 Node.js（如 Express / NestJS）作为后端服务。
- **云端数据库**：
  - 可选 SQLite（单机轻量）或 PostgreSQL / MySQL 等关系型数据库。
  - 存储结构与本地 `items` 表基本一致，以便简化同步逻辑。
- **网络与安全**：
  - 所有 API 通过 HTTPS 访问。
  - 使用 Token（如 JWT）进行用户认证，区分不同用户的数据空间。

## 5. 数据模型设计

### 5.1 本地 SQLite 表：`items`

| 字段名                        | 类型      | 说明                                           |
|------------------------------|-----------|----------------------------------------------|
| `id`                         | INTEGER   | 本地主键，自增                                |
| `remote_id`                  | TEXT      | 对应云端记录的唯一 ID（UUID 等），可为空     |
| `name`                       | TEXT      | 物品名称                                      |
| `purchased_at`               | TEXT      | 购买日期（ISO 日期字符串）                    |
| `price_cents`                | INTEGER   | 购买价格（以“分”为单位）                      |
| `remark`                     | TEXT      | 备注                                          |
| `archived`                   | INTEGER   | 是否归档（0=否，1=是）                        |
| `archived_at`                | TEXT      | 归档时间（ISO 字符串，未归档则为空）         |
| `archived_daily_price_cents` | INTEGER   | 归档时锁定的日均价格（分，未归档则为空）     |
| `sync_status`                | INTEGER   | 同步状态：0=未同步，1=已同步，2=待更新，3=待删除 |
| `last_synced_at`             | TEXT      | 最近一次同步成功时间（ISO 字符串，可为空）   |
| `created_at`                 | TEXT      | 记录创建时间（ISO 字符串）                    |
| `updated_at`                 | TEXT      | 最近更新时间（ISO 字符串）                    |

> 日均价格展示逻辑：
> - 未归档：根据 `purchased_at` 和当前日期计算使用天数，使用 `price_cents / 使用天数` 计算。
> - 已归档：直接使用 `archived_daily_price_cents`。

### 5.2 云端数据库表：`items`

云端 `items` 表字段建议与本地结构保持高度一致，区别在于主键字段：

| 字段名                        | 类型      | 说明                                           |
|------------------------------|-----------|----------------------------------------------|
| `id`                         | TEXT      | 云端主键（UUID）                              |
| `user_id`                    | TEXT      | 所属用户 ID，用于区分不同用户                 |
| `name`                       | TEXT      | 物品名称                                      |
| `purchased_at`               | TEXT      | 购买日期                                      |
| `price_cents`                | INTEGER   | 购买价格（分）                                |
| `remark`                     | TEXT      | 备注                                          |
| `archived`                   | INTEGER   | 是否归档                                      |
| `archived_at`                | TEXT      | 归档时间                                      |
| `archived_daily_price_cents` | INTEGER   | 归档日均价格（分）                            |
| `created_at`                 | TEXT      | 创建时间                                      |
| `updated_at`                 | TEXT      | 更新时间                                      |

## 6. 同步流程设计

### 6.1 本地 → 云端（上行同步）

1. 查找本地需要同步的记录：
   - `sync_status = 0`：本地新建但未同步的记录。
   - `sync_status = 2`：本地已同步过但有更新的记录。
   - `sync_status = 3`：本地标记为删除但未同步删除的记录。
2. 根据不同状态调用对应云端 API：
   - 新增：
     - 调用 `POST /api/items` 创建云端记录。
     - 云端返回新建记录的 `id`（远端 ID），本地将该值写入 `remote_id`，并将 `sync_status` 置为 1、更新 `last_synced_at`。
   - 更新：
     - 调用 `PUT /api/items/:id`（使用 `remote_id`）更新云端记录。
     - 成功后，本地将 `sync_status` 置为 1，更新 `last_synced_at`。
   - 删除：
     - 调用 `DELETE /api/items/:id` 删除云端记录。
     - 成功后，本地可以物理删除该条记录，或将其保留为本地“墓碑”（视需求而定）。

### 6.2 云端 → 本地（下行同步）

1. 本地维护一个“最后云端拉取时间”（可存配置表或本地配置文件）。
2. 发起请求：
   - `GET /api/items?updated_after=<ISO时间>`
3. 云端返回自该时间以来被创建或修改的记录列表。
4. 客户端逐条处理：
   - 若本地不存在对应 `remote_id`：
     - 在本地新建记录，`sync_status = 1`，设置 `last_synced_at`。
   - 若本地已存在：
     - 比较本地与云端的 `updated_at`：
       - 云端较新 → 以云端数据覆盖本地。
       - 本地较新 → 保持本地记录不变，等待下次上行同步覆盖云端。
5. 同步完成后，更新本地“最后云端拉取时间”。

## 7. API 接口设计（初稿）

### 7.1 鉴权

- **登录接口**
  - `POST /api/auth/login`
  - 接收账号密码（或其他认证方式），返回 Token（如 JWT）。
- **后续接口鉴权方式**
  - 所有需要访问用户数据的接口通过 Header：
    - `Authorization: Bearer <token>`

### 7.2 Items 相关接口

- **创建物品**
  - `POST /api/items`
  - 请求体示例：
    ```json
    {
      "name": "MacBook Pro",
      "purchased_at": "2024-01-01",
      "price_cents": 120000,
      "remark": "工作用电脑",
      "archived": 0,
      "archived_at": null,
      "archived_daily_price_cents": null,
      "created_at": "2024-01-01T10:00:00Z",
      "updated_at": "2024-01-01T10:00:00Z"
    }
    ```
  - 响应示例：
    ```json
    {
      "id": "uuid-from-server",
      "name": "MacBook Pro",
      "purchased_at": "2024-01-01",
      "price_cents": 120000,
      "remark": "工作用电脑",
      "archived": 0,
      "archived_at": null,
      "archived_daily_price_cents": null,
      "created_at": "2024-01-01T10:00:00Z",
      "updated_at": "2024-01-01T10:00:00Z"
    }
    ```

- **更新物品**
  - `PUT /api/items/:id`
  - 请求体可与创建基本一致。
  - 响应返回更新后的完整记录。

- **删除物品**
  - `DELETE /api/items/:id`
  - 可以返回 204（无内容）或包含简要结果的 200 响应。

- **增量获取物品（用于同步）**
  - `GET /api/items?updated_after=<ISO时间>`
  - 响应示例：
    ```json
    [
      {
        "id": "uuid-1",
        "name": "MacBook Pro",
        "purchased_at": "2024-01-01",
        "price_cents": 120000,
        "remark": "工作用电脑",
        "archived": 0,
        "archived_at": null,
        "archived_daily_price_cents": null,
        "created_at": "2024-01-01T10:00:00Z",
        "updated_at": "2024-01-02T08:00:00Z"
      },
      {
        "id": "uuid-2",
        "name": "iPad",
        "purchased_at": "2024-02-01",
        "price_cents": 60000,
        "remark": "",
        "archived": 1,
        "archived_at": "2024-06-01T10:00:00Z",
        "archived_daily_price_cents": 500,
        "created_at": "2024-02-01T09:00:00Z",
        "updated_at": "2024-06-01T10:00:00Z"
      }
    ]
    ```

## 8. 界面与交互需求

### 8.1 物品列表页

- 展示信息：
  - 物品名称
  - 当前日均价格（进行中：动态计算；归档：使用锁定值）
  - 使用天数（根据状态不同展示“至今日”或“至归档日”）
  - 状态标识（进行中 / 已归档）
- 功能操作：
  - 新建物品
  - 编辑物品
  - 归档/取消归档
  - 删除物品
  - 筛选：进行中 / 已归档 / 全部
  - 同步按钮：触发本地与云端的数据同步

### 8.2 物品详情页

- 展示内容：
  - 名称、购买时间、购买价格、备注
  - 使用天数
  - 日均价格
  - 状态（进行中 / 已归档）
  - 归档时间（若已归档）
- 操作：
  - 编辑基础信息
  - 归档 / 取消归档
  - 删除物品
  - 手动同步（可选：在详情页内也提供同步入口）

### 8.3 新建 / 编辑物品页面

- 表单字段：
  - 名称（必填）
  - 购买日期（必填）
  - 购买价格（必填，可输入小数，内部转换为“分”）
  - 备注（可选）
- 表单校验：
  - 必填项不能为空。
  - 购买价格必须为非负数。
  - 购买日期不应晚于当前日期（可选校验）。

## 9. 后续扩展方向

- **分类与标签**：为物品添加分类/标签，支持按类别统计成本。
- **统计报表**：
  - 按时间段统计投入金额、归档物品数、平均日均成本等。
- **数据导出与导入**：
  - 支持导出为 CSV / JSON 文件。
  - 支持从文件导入历史数据。
- **更高级的同步与版本管理**：
  - 引入变更日志表，支持查看历史版本。
  - 提供冲突时的人工选择界面。

## 10. 开发任务清单（用于统计进度）

- [ ] 初始化 Next.js + TypeScript 项目（使用 App Router）
- [ ] 集成 Capacitor（Android 项目初始化）
- [ ] 设计并实现本地 SQLite 数据访问层
- [ ] 设计并实现云端数据库和 API（含鉴权与 items 接口）
- [ ] 实现物品列表页（含筛选与同步按钮）
- [ ] 实现物品详情页（含归档/取消归档）
- [ ] 实现新建/编辑物品表单与校验
- [ ] 实现本地 ↔ 云端双向同步逻辑
- [ ] 测试 Web 端与 Android 端的核心功能

## 11. 总结

本项目是一个面向个人的 **物品成本管理 + 多端同步** 工具，具备以下特点：

1. 本地 SQLite 存储，离线可用，保证数据安全掌握在自己手里。
2. 清晰的使用天数和日均价格计算逻辑，支持归档时锁定最终成本。
3. 通过云端数据库和同步机制，实现 Web 与 Android 端的数据一致性与共享。
4. 技术栈基于 Next.js + Capacitor + SQLite，部署灵活，可运行于个人云服务器和本地设备。
